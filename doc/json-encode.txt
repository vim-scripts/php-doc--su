json_encode -- Returns the JSON representation of a value

  string json_encode(mixed value [, int options])~

Returns a string containing the JSON representation of {value}.

{value} The {value} being encoded. Can be any type except a resource.

This function only works with UTF-8 encoded data.

{options} Bitmask consisting of JSON_HEX_QUOT, JSON_HEX_TAG, JSON_HEX_AMP,
JSON_HEX_APOS, JSON_NUMERIC_CHECK, JSON_PRETTY_PRINT, JSON_UNESCAPED_SLASHES,
JSON_FORCE_OBJECT, JSON_UNESCAPED_UNICODE.

Returns a JSON encoded string on success.

Version Description 5.4.0 JSON_BIGINT_AS_STRING, JSON_PRETTY_PRINT,
JSON_UNESCAPED_SLASHES, and JSON_UNESCAPED_UNICODE {options} were added. 5.3.3
JSON_NUMERIC_CHECK {option} was added. 5.3.0 The {options} parameter was
added. 5.2.1 Added support for JSON encoding of basic types.

A |json_encode| example

<?php >
  $arr = array('a' => 1, 'b' => 2, 'c' => 3, 'd' => 4, 'e' => 5);
  
  echo json_encode($arr);
?>

The above example will output:

  {"a":1,"b":2,"c":3,"d":4,"e":5}

A |json_encode| example showing all the options in action

<?php >
  $a = array('<foo>',"'bar'",'"baz"','&amp;blong&', "\xc3\xa9");
  
  echo "Normal: ",  json_encode($a), "\n";
  echo "Tags: ",    json_encode($a, JSON_HEX_TAG), "\n";
  echo "Apos: ",    json_encode($a, JSON_HEX_APOS), "\n";
  echo "Quot: ",    json_encode($a, JSON_HEX_QUOT), "\n";
  echo "Amp: ",     json_encode($a, JSON_HEX_AMP), "\n";
  echo "Unicode: ", json_encode($a, JSON_UNESCAPED_UNICODE), "\n";
  echo "All: ",     json_encode($a, JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_QUOT | JSON_HEX_AMP | JSON_UNESCAPED_UNICODE), "\n\n";
  
  $b = array();
  
  echo "Empty array output as array: ", json_encode($b), "\n";
  echo "Empty array output as object: ", json_encode($b, JSON_FORCE_OBJECT), "\n\n";
  
  $c = array(array(1,2,3));
  
  echo "Non-associative array output as array: ", json_encode($c), "\n";
  echo "Non-associative array output as object: ", json_encode($c, JSON_FORCE_OBJECT), "\n\n";
  
  $d = array('foo' => 'bar', 'baz' => 'long');
  
  echo "Associative array always output as object: ", json_encode($d), "\n";
  echo "Associative array always output as object: ", json_encode($d, JSON_FORCE_OBJECT), "\n\n";
?>

The above example will output:

  Normal: ["<foo>","'bar'","\"baz\"","&blong&","\u00e9"]
  Tags: ["\u003Cfoo\u003E","'bar'","\"baz\"","&blong&","\u00e9"]
  Apos: ["<foo>","\u0027bar\u0027","\"baz\"","&blong&","\u00e9"]
  Quot: ["<foo>","'bar'","\u0022baz\u0022","&blong&","\u00e9"]
  Amp: ["<foo>","'bar'","\"baz\"","\u0026blong\u0026","\u00e9"]
  Unicode: ["<foo>","'bar'","\"baz\"","&blong&","é"]
  All: ["\u003Cfoo\u003E","\u0027bar\u0027","\u0022baz\u0022","\u0026blong\u0026","é"]
  
  Empty array output as array: []
  Empty array output as object: {}
  
  Non-associative array output as array: [[1,2,3]]
  Non-associative array output as object: {"0":{"0":1,"1":2,"2":3}}
  
  Associative array always output as object: {"foo":"bar","baz":"long"}
  Associative array always output as object: {"foo":"bar","baz":"long"}



In the event of a failure to encode, |json_last_error| can be used to
determine the exact nature of the error.

|json_decode| |json_last_error|

vim:ft=help:
